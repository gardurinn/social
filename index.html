<!DOCTYPE html>
<html lang="en">
    <head>
        <link rel="stylesheet" href="/styles/style.css">
        <meta charset="utf-8">
        <meta name="description" content="Final Assignment in Social Data and Visualization. This web page contains the visualization of 311 data in New York">
        <meta name="authour" content="Anna, Lovisa and Margret ">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Social Data - Final Assignment</title>
        <script type="text/javascript" src="../d3/d3.v3.js"></script>
        <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>


    </head>
    <body>

        <header><h1> 311 Noise Complaints </h1></header>
       
         <div class="textcontainer">
         <p>
            The dataset has around 172 complaints types. To visualize all 172 complaint types a bar chart was made, and can be seen below.  Then a raw scatter pot of the longtitude and latitudes was made, and that showed some complaints that were not listed in NY, so they were filtered out. Then the second largest complaint type category was chosen; Noise â€“ Residential. Then a bar plot was made to show the four different dicriptors that the noise complaints are catogorised into. They are:</p>
             <li> Banging/Pounding</li>
             <li> Loud Music/Party</li>
             <li>Loud Talking</li>
             <li>Loud Television</li>
           <p> This bar plot can be seen here below. Then the age data was inspected and made a bar chart of the number of residents per Borough.  To get a better idea of the age,  a stacked bar plot of the age data was made. 
            To visualize the total number of complaints in each Borough and total number of noise complaints in each Borough a scatter plot was made. There the the main data was summerised, were the number of residents representes the radian of the circles in the scatter plot. Therefore the scatterplot shows: </p>
              <li> Total number of residents for each borough</li>
              <li> Total number of complaints for each borough</li>
              <li>Total number of noise complaints for each borough</li>
        
         </div>

            <div class="plot3 container">
            <p id="graphTitle"> Type of Complaints </p>
            </div>
            

            <div class="plot2 container">
            <p id="graphTitle"> Type of Noise Complaints </p> 
            </div>        
            
            <!-- <div class="container"> 
            <p id="graphTitle"> Average age in New York </p>
            <div class="figContainer">
            <img src="/fig/Age_NewYork.png" style="width:50px;height:50px;float: right"> 
            </div>
            </div>        
 -->
            <div class="plot1 container">
            <p id="graphTitle"> Noise Complaints vs. Total number of Complaints </p>
            </div>
   
            <div class="container">
                <p id="graphTitle"> KNN </p>
                <div style="margin: 20px">
                <p>The KNN will indicates where each category of noise complaint is the most problematic. Each prediction point is classified according to its nearest neighbor. The data could help the police to prevent these noise complaints by knowing where the type of noise complaint is the most. This also helps understanding where each descriptor is dominant in each area. The method is done for both balanced and unbalance data, and the result are shown for both. The map shows a geoplot of New York City. The buttons are used so we can toggle between the KNeighborsClassifier = 3, 15 and 30. The colors that describe each category are the following:</p>
                <li style="color:#4286f4";>Banging/Pounding: Blue</li>
                <li style="color:#f47d41";>Loud music/Party: Orange</li>
                <li style="color:#f4f441";>Loud Talking: Yellow</li>
                </div>  
                    <div>
                   <button id="Z3" class="KNN_Button">Z3</button>
                   <button id="Z15" class="KNN_Button">Z15</button>
                   <button id="Z30" class="KNN_Button">Z30</button>
                    </div>    
               <div class="KNN"></div>
            </div>

            <div class="container">
                  <p id="graphTitle"> Clustering </p>
                <div>
                <p>The method shows us how the noise complaints are spread over NYC. This will help us to estimate were the most complaints are filed for each Descriptor. For different types of complaints we can both compare the location of the centers and how it changes when different number of centers are chosen. If the centers are close together it indicates that a lot of the complaints are filed in the same area. 
                The buttons represent the number of centers
                The map shows a geoplot of New York City. On the map we visualize K-means clustering, for K = 2,.., 6. The buttons below represent how many clusters, with a centroid, will be shown. The centroids are represented with a large white circle and the clustered data is shown with multiple colors. </p>
                </div>
              <button id="KMean2" class="kernelButton">K2</button>
              <button id="KMean3" class="kernelButton">K3</button>
              <button id="KMean4" class="kernelButton">K4</button>
              <button id="KMean5" class="kernelButton">K5</button>
              <button id="KMean6" class="kernelButton">K6</button>

            <div class="Clust_container">
            </div>
            </div>

        <script type="text/javascript">

        //Width and height
        var w=700;
        var h=200;
        var padding = 50;
        var padding1=30;


        var dataset;
            d3.csv("/Data/Scatter_data.csv", function(dataset) {
            // Strings to number
            dataset.forEach(function(d) {
                d.NoiseComplaints = +d.NoiseComplaints;
                d.Total2015 = +d.Total2015;
               // d.Borough = +d.Borough;
                d.NumRes2015 = +d.NumRes2015;
             });
            console.log(dataset);

   

    // Create the scales
            var xScale = d3.scale.linear()
                                 .domain([0, d3.max(dataset, function(d) { return d['Total2015']; }) ])
                                 .range([padding1*3, w - padding1*4 ]);

            var yScale = d3.scale.linear()
                                 .domain([0, d3.max(dataset, function(d) { return d['NoiseComplaints']; }) ])
                                 .range([h - padding1, padding1]);  

            var rScale = d3.scale.linear()
                                 .domain([0, d3.max(dataset, function(d) { return d['Total2015']; })])
                                 .range([3, 20]);     


        // Define x and y axis
        var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient("bottom")
                .ticks(5);
        var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient("left")
                .ticks(8);  

     //Create SVG element
            var svg = d3.select(".plot1")
                        .append("svg")
                        .attr("width", w)
                        .attr("height", h); 

    // Append the circles
                     svg.selectAll("circle")
                       .data(dataset)
                       .enter()
                       .append("circle")
                       .attr("fill", "#D91E0D")
                       .attr("stroke", '#f2b632')

                       .attr("cx", function(d) {
                            return xScale(d['Total2015']);
                       })
                       .attr("cy", function(d) {
                            return yScale(d['NoiseComplaints']);
                       })
                       .attr("r", function(d) {
                            return rScale(d['Total2015']);

                       });   


    //Create labels
        var labels = svg.selectAll("text")
                .data(dataset)
                .enter()
                .append("text")
                .text(function(d) {
                    return d['Borough'];
             })
                .attr("x", function(d) {
                    return xScale(d['Total2015'])+d["NumRes2015"]/200000+10;
            })
               .attr("y", function(d) {
                    return yScale(d['NoiseComplaints'])-d["NumRes2015"]/200000;
               })
               .attr("class", "labels")
               .attr("fill", "#8C0404");                                                     
          
          //Create X-axis
        svg.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(0," + (h-padding) + ")")
                .call(xAxis);
        //Create Y-axis
        svg.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(" + padding + ",0)")
                .call(yAxis);

});


// --------------------------------------------- Plot nr.2 ------------------------------------------------ // 
                //Width and height
        var w=700;
        var h=400;
        var padding=50;
        var barPadding = 30;
        
        
        var dataset2 = [["Banging/Pounding",51832], ["Loud Music/Party",136290], ["Loud Talking",13922],["Loud Television",3782]];
        console.log(dataset2);

    //Define y scale
         var yScale = d3.scale.linear()
              .domain([0, d3.max(dataset2, function(d) { return d; }) ])
              .range([h - barPadding, barPadding]); 



    //Define  axis
    var yAxis = d3.svg.axis()
              .scale(yScale)
              .orient("left")
              .ticks(10)


        var svg = d3.select(".plot2")
                .append("svg")
                .attr("width",w)
                .attr("height",h);


            svg.selectAll("rect")
               .data(dataset2)
               .enter()
               .append("rect")
               .attr("x", function(d, i) {
                    return i * (w / dataset2.length);
               })
               .attr("y", function(d) {
                    return h - (d[1] / 400+ barPadding);
               })
               .attr("width", w / dataset2.length - 10)
               .attr("height", function(d) {
                    return d[1] / 10;
               })
               .attr("fill", "#D91E0D");
       
            // //Create Y axis
            // svg.append("g")
            //     .attr("class", "axis")
            //     .attr("transform", "translate(0," + 20 + ")")
            //     .call(yAxis);


            svg.selectAll("text")
               .data(dataset2)
               .enter()
               .append("text")
               .text(function(d) {
                    return d[0];
               })
               .attr("text-anchor", "middle")
               .attr("x", function(d, i) {
                    return i * (w / dataset2.length) + (w / dataset2.length - barPadding) / 2;
               })
               .attr("y", function(d) {
                    return h - (d[1] /400 + 0.5*barPadding ) ;
               })
               .attr("font-family", "sans-serif")
               .attr("font-size", "12px")
               .attr("fill", "#F2F2F2 ");      


// --------------------------------------------- Plot nr.3 ------------------------------------------------ // 

        //Width and height
        var w=700;
        var h=400;
        var padding3=50;
        var barPadding3 = 500;


        
        var dataset3;
            d3.csv("/Data/ComplaintTypeTotal2.csv", function(dataset3) {
               // Strings to number
            dataset3.forEach(function(d) {
                d.Total = +d.Total;
             });
            console.log(dataset3);

         var yScale = d3.scale.linear()
              .domain([0, d3.max(dataset3, function(d) { return d.Total; }) ])
              .range([h - 20, 10]); 

        //Define Y axis
        var yAxis = d3.svg.axis()
                          .scale(yScale)
                          .orient("left")
                          .ticks(5);



         var svg = d3.select(".plot3")
            .append("svg")
            .attr("width",w)
            .attr("height",h);


            svg.selectAll("rect")
               .data(dataset3)
               .enter()
               .append("rect")
               .attr("class", "rect")
               .attr("x", function(d, i) {
                    return i * (w / dataset3.length);
               })
               .attr("y", function(d) {
                    return h - (d.Total / 500);
               })
               .attr("width", w / dataset3.length )

               .attr("height", function(d) {
                    return (d.Total/600)+barPadding3;
               })
               .attr("fill", function(d) {
                          if (d.Name == "A172") {
                        
                          return "#F2E205";
                        } else           {
                          return "#D91E0D";
                        }
                      });
        
        //Create Y axis
            svg.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(" + padding3 + ",0)")
                .call(yAxis);

    });

    // -----------------------------  Variables for maps and circles ----------------------------------------------//
      // color for circles
      var color = ['#4286f4','#f47d41', '#f4f441', '#41f441','#eb41f4','red'];
      var colors = ['#4286f4','#f47d41', '#f4f441', '#41f441','#eb41f4','red'];
                    //Width and height
                    var w2 = 600;
                    var h = 550;
                    //Define map projection
                    var projection = d3.geo.mercator()
                            .center([-73.831435312936435, 40.789187433613968])
                            .scale(40000)
    //              .center([-122.41819474198758, 37.774145825475955])
    //              .scale(200000)
                            .translate([w2 / 2, h / 2]);


// --------------------------------- KNN VARIABLES -------------------------------------------------------//
                    //Define path generator
                    var path_balance = d3.geo.path()
                                                     .projection(projection);
            var path_unbalance = d3.geo.path()
                              .projection(projection);

                    //Create SVG element
                    var svg_balance = d3.select(".KNN")
                                            .append("svg")
                                            .attr("width", w2)
                                            .attr("height", h);
           var svg_unbalance = d3.select(".KNN")
                                .append("svg")
                                .attr("width", w2)
                                .attr("height", h);

                    var Map_balance = svg_balance.append("g");
                    var locations_balance = svg_balance.append("g");
                    var centers_balance = svg_balance.append("g");

                    var Map_unbalance = svg_unbalance.append("g");
                    var locations_unbalance = svg_unbalance.append("g");
                    var centers_unbalance = svg_unbalance.append("g");


                var tip = d3.tip()
                  .attr('class', 'd3-tip')
                  .offset([0,100])
                  .html(function(d) {
                  if (d['properties']['BoroName'] == 'Bronx'){
                    return  "<div  class='tiphead' ><strong>"+ d[['properties']]['BoroName'] +"</strong></div>" +
          "<div><strong>Num of noise complaints:</strong> <span class='tipperCol' >" + '23.9%' + "</span></div>" +
          "<div><strong>Num of residents:</strong> <span class='tipperCol' >" + '16.9%' + "</span></div>" +
          "<div><strong>Average age:</strong> <span class='tipperCol' >" + '35.0 year' + "</span></div>" ;
                  }
                  else if (d['properties']['BoroName'] == 'Brooklyn'){
                    return  "<div  class='tiphead' ><strong>"+ d[['properties']]['BoroName'] +"</strong></div>" +
          "<div><strong>Num of noise complaints:</strong> <span class='tipperCol' >" + '30.4%' + "</span></div>" +
          "<div><strong>Num of residents:</strong> <span class='tipperCol' >" + '31.0%' + "</span></div>" +
          "<div><strong>Average age:</strong> <span class='tipperCol' >" + '36.3 year' + "</span></div>" ;
                  }
                  else if (d['properties']['BoroName'] == 'Queens'){
                    return  "<div  class='tiphead' ><strong>"+ d[['properties']]['BoroName'] +"</strong></div>" +
          "<div><strong>Num of noise complaints:</strong> <span class='tipperCol' >" + '20.0%' + "</span></div>" +
          "<div><strong>Num of residents:</strong> <span class='tipperCol' >" + '27.3%' + "</span></div>" +
          "<div><strong>Average age:</strong> <span class='tipperCol' >" + '38.1 year' + "</span></div>" ;
                  }
                  else if (d['properties']['BoroName'] == 'Staten Island'){
                    return  "<div  class='tiphead' ><strong>"+ d[['properties']]['BoroName'] +"</strong></div>" +
          "<div><strong>Num of noise complaints:</strong> <span class='tipperCol' >" + '3.0%' + "</span></div>" +
          "<div><strong>Num of residents:</strong> <span class='tipperCol' >" + '5.7%' + "</span></div>" +
          "<div><strong>Average age:</strong> <span class='tipperCol' >" + '38.6 year' + "</span></div>" ;
                  }
                  else{
                    return  "<div  class='tiphead' ><strong>"+ d[['properties']]['BoroName'] +"</strong></div>" +
          "<div><strong>Num of noise complaints:</strong> <span class='tipperCol' >" + '22.7%' + "</span></div>" +
          "<div><strong>Num of residents:</strong> <span class='tipperCol' >" + '19.2%' + "</span></div>" +
          "<div><strong>Average age:</strong> <span class='tipperCol' >" + '39.1 year' + "</span></div>" ;
                  }
                  });
            svg_balance.call(tip);
            svg_unbalance.call(tip);


            // Add a title to the graph
            svg_balance.append("text")
                .attr("x", (w2 / 2))
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .attr("fill", "#8C0404")
                .attr("font-family", "sans-serif")
                .style("font-size", "20px")
                .text("KNN - Balance");

        svg_unbalance.append("text")
        .attr("x", (w2 / 2))
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .attr("fill", "#8C0404")
        .attr("font-family", "sans-serif")
        .style("font-size", "20px")
        .text("KNN - Unbalance");



// ---------------------------------------------------------------------------------------------//


// --------------------------------- MAPS FOR KNN ---------------------------------------//
// Map for balance data
                            //Bind data and create one path per GeoJSON feature
                         d3.json("https://raw.githubusercontent.com/dwillis/nyc-maps/master/boroughs.geojson", function(json){
                    //      d3.json("https://raw.githubusercontent.com/suneman/socialdataanalysis2017/master/files/sfpddistricts.geojson", function(json){
                    Map_balance.selectAll("path")
                                    .data(json.features)
                    .enter()
                   .append("path")
                   .attr("d", path_balance)
                   .on('mouseover', tip.show)
                       .on('mouseout', tip.hide)
                   .attr('stroke-width',2)
                       .attr('stroke',"#626262")
                       .attr('class','mapDistrict')

                   // Map for unbalance data
     //Bind data and create one path per GeoJSON feature
              d3.json("https://raw.githubusercontent.com/dwillis/nyc-maps/master/boroughs.geojson", function(json){
                Map_unbalance.selectAll("path")
                .data(json.features)
                .enter()
                .append("path")
                .attr("d", path_balance)
                .on('mouseover', tip.show)
                .on('mouseout', tip.hide)
                .attr('stroke-width',2)
                .attr('stroke',"#626262")
                .attr('class','mapDistrict')


            var labels = svg_balance.append('g').attr('class', 'labels');

            //Adding labels as seen on http://bl.ocks.org/pgiraud/9f400d54ce2ea7b4f820
            labels.selectAll('.label').data(json.features).enter().append('text')
                .attr('transform', function(d) {
                    return "translate(" + path_balance.centroid(d) + ")";
                })
                .style('text-anchor', 'middle')
                .text(function(d) {
                    return d.properties.BoroName
                });
            labels.selectAll('.label').data(json.features).enter().append('text')
                .attr('transform', function(d) {
                    return "translate(" + path_balance.centroid(d) + ")";
                })
                .style('text-anchor', 'middle')
                .text(function(d) {
                    return d.properties.BoroName
                });

          var labels = svg_unbalance.append('g').attr('class', 'labels');

                //Adding labels as seen on http://bl.ocks.org/pgiraud/9f400d54ce2ea7b4f820
                labels.selectAll('.label').data(json.features).enter().append('text')
                    .attr('transform', function(d) {
                        return "translate(" + path_unbalance.centroid(d) + ")";
                    })
                    .style('text-anchor', 'middle')
                    .text(function(d) {
                        return d.properties.BoroName
                    });
                labels.selectAll('.label').data(json.features).enter().append('text')
                    .attr('transform', function(d) {
                        return "translate(" + path_unbalance.centroid(d) + ")";
                    })
                    .style('text-anchor', 'middle')
                    .text(function(d) {
                        return d.properties.BoroName
                    });


//-------------------------------------------------------------------------------------------- //

// -------------------------------- BEGINNING -------------------------------------------------- //

//Draw the location data points and the kmeans center points
drawKNN('Z3');
// -------------------------------------------------------------------------------------------//

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
//                            FUNCTIONS
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //

// ------------------------------------------------------------------------------------------ //
//                        CLUSTERING
// ------------------------------------------------------------------------------------------ //

// ------------------------------------- DRAW KNN -------------------------------------- //

                    function drawKNN(k_ID) {
                            locations_balance.selectAll("circle").remove()
                            locations_unbalance.selectAll("circle").remove()
              //            d3.csv("DataSet2B_final.csv", function(data_loc) {
                            d3.csv("/Data/knn_balance.csv", function(data_loc) {
                                   locations_balance.selectAll("circle")
                                   .data(data_loc)
                                   .enter()
                                   .append("circle")
                                   .attr("cx", function(d) {
                                       return projection([d.X, d.Y])[0];
                                   })
                                   .attr("cy", function(d) {
                                       return projection([d.X, d.Y])[1];
                                   })
                                   .attr("r", 2.5)
                                   .style("fill", function(d){
                           var value = d[k_ID];
                                         return color[value];
                         })
                         .style("opacity",0.9);
                                });
                           d3.csv("/Data/knn_unbalance.csv", function(data_loc) {
                                 locations_unbalance.selectAll("circle")
                                 .data(data_loc)
                                 .enter()
                                 .append("circle")
                                 .attr("cx", function(d) {
                                 return projection([d.X, d.Y])[0];
                                   })
                                 .attr("cy", function(d) {
                                       return projection([d.X, d.Y])[1];
                                 })
                                 .attr("r", 2.5)
                                 .style("fill", function(d){
                                   var value = d[k_ID];
                                  return color[value];
                             })
                             .style("opacity",0.9);
                  //           .attr("stroke", "black");
                                    });

                            }
// ---------------------------------------------------------------------------------------- //


  // ------------------------------ KNN BUTTONS ---------------------------------------------------- //

    d3.selectAll(".KNN_Button").on("click", function(){
                buttonID = d3.select(this).attr("id")
                drawKNN(buttonID)
                console.log(buttonID)
                });
// ----------------------------------------------------------------------------------------------------- //

                });
              });

    // -----------------------------  Variables for maps and circles ----------------------------------------------//
      // color for circles
      var color = ['#4286f4','#f47d41', '#f4f441', '#41f441','#eb41f4','red'];

                    //Width and height
                    var w2 = 600;
                    var h = 550;
                    //Define map projection
                    var projection = d3.geo.mercator()
                            .center([-73.831435312936435, 40.789187433613968])
                            .scale(40000)
    //              .center([-122.41819474198758, 37.774145825475955])
    //              .scale(200000)
                            .translate([w2 / 2, h / 2]);


// --------------------------------- CLUSTER VARIABLES -------------------------------------------------------//
                    //Define path generator
                    var path_bang = d3.geo.path()
                                                     .projection(projection);
            var path_musik = d3.geo.path()
                              .projection(projection);
            var path_talk = d3.geo.path()
                              .projection(projection);
            var path_tv = d3.geo.path()
                            .projection(projection);
                    //Create SVG element
                    var svg_bang = d3.select(".Clust_container")
                                            .append("svg")
                                            .attr("width", w2)
                                            .attr("height", h);
           var svg_musik = d3.select(".Clust_container")
                                .append("svg")
                                .attr("width", w2)
                                .attr("height", h);
            var svg_talk = d3.select(".Clust_container")
                                    .append("svg")
                                    .attr("width", w2)
                                    .attr("height", h);
            var svg_tv = d3.select(".Clust_container")
                                .append("svg")
                                .attr("width", w2)
                                .attr("height", h);

                    var Map_bang = svg_bang.append("g");
                    var locations_bang = svg_bang.append("g");
                    var centers_bang = svg_bang.append("g");

                    var Map_musik = svg_musik.append("g");
                    var locations_musik = svg_musik.append("g");
                    var centers_musik = svg_musik.append("g");

            var Map_talk = svg_talk.append("g");
            var locations_talk = svg_talk.append("g");
            var centers_talk = svg_talk.append("g");

            var Map_tv = svg_tv.append("g");
            var locations_tv = svg_tv.append("g");
            var centers_tv = svg_tv.append("g");

            // Add a title to the graph
            svg_bang.append("text")
                .attr("x", (w2 / 2))
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .attr("fill", "#8C0404")
                .attr("font-family", "sans-serif")
                .style("font-size", "20px")
                .text("Banging/Pounding");

        svg_musik.append("text")
        .attr("x", (w2 / 2))
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .attr("fill", "#8C0404")
        .attr("font-family", "sans-serif")
        .style("font-size", "20px")
        .text("Loud Music/party");

        svg_talk.append("text")
        .attr("x", (w2 / 2))
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .attr("fill", "#8C0404")
        .attr("font-family", "sans-serif")
        .style("font-size", "20px")
        .text("Loud Talking");

        svg_tv.append("text")
        .attr("x", (w2 / 2))
        .attr("y", 30)
        .attr("text-anchor", "middle")
        .attr("fill", "#8C0404")
        .attr("font-family", "sans-serif")
        .style("font-size", "20px")
        .text("Loud Television");

// ---------------------------------------------------------------------------------------------//


// --------------------------------- MAPS FOR CLUSTERING ---------------------------------------//
// Map for banging
                            //Bind data and create one path per GeoJSON feature
                         d3.json("https://raw.githubusercontent.com/dwillis/nyc-maps/master/boroughs.geojson", function(json){
                    //      d3.json("https://raw.githubusercontent.com/suneman/socialdataanalysis2017/master/files/sfpddistricts.geojson", function(json){
                    Map_bang.selectAll("path")
                                    .data(json.features)
                                    .enter()
                                    .append("path")
                                    .attr("d", path_bang)
                                    .style("fill", "#E6E6E6")
                                    .attr('stroke-width',2)
                                    .attr('stroke',"#626262");
// Map for loud musik
                    //Bind data and create one path per GeoJSON feature
                        d3.json("https://raw.githubusercontent.com/dwillis/nyc-maps/master/boroughs.geojson", function(json){
                        //      d3.json("https://raw.githubusercontent.com/suneman/socialdataanalysis2017/master/files/sfpddistricts.geojson", function(json){
                      Map_musik.selectAll("path")
                                    .data(json.features)
                                    .enter()
                                    .append("path")
                                    .attr("d", path_musik)
                                    .style("fill", "#E6E6E6")
                                    .attr('stroke-width',2)
                                    .attr('stroke',"#626262");
 // Map for loud talking
                //Bind data and create one path per GeoJSON feature
                d3.json("https://raw.githubusercontent.com/dwillis/nyc-maps/master/boroughs.geojson", function(json){
                Map_talk.selectAll("path")
                .data(json.features)
                .enter()
                .append("path")
                .attr("d", path_talk)
                .style("fill", "#E6E6E6")
                .attr('stroke-width',2)
                .attr('stroke',"#626262");
// Map for loud talking
  //Bind data and create one path per GeoJSON feature
                d3.json("https://raw.githubusercontent.com/dwillis/nyc-maps/master/boroughs.geojson", function(json){
                  Map_tv.selectAll("path")
                  .data(json.features)
                  .enter()
                  .append("path")
                  .attr("d", path_tv)
                  .style("fill", "#E6E6E6")
                  .attr('stroke-width',2)
                  .attr('stroke',"#626262");



                                var labels = svg_tv.append('g').attr('class', 'labels');

                                //Adding labels as seen on http://bl.ocks.org/pgiraud/9f400d54ce2ea7b4f820
                                labels.selectAll('.label').data(json.features).enter().append('text')
                                    .attr('transform', function(d) {
                                        return "translate(" + path_tv.centroid(d) + ")";
                                    })
                                    .style('text-anchor', 'middle')
                                    .text(function(d) {
                                        return d.properties.BoroName
                                    });
                                labels.selectAll('.label').data(json.features).enter().append('text')
                                    .attr('transform', function(d) {
                                        return "translate(" + path_tv.centroid(d) + ")";
                                    })
                                    .style('text-anchor', 'middle')
                                    .text(function(d) {
                                        return d.properties.BoroName
                                    });


                                        var labels = svg_bang.append('g').attr('class', 'labels');

                                        //Adding labels as seen on http://bl.ocks.org/pgiraud/9f400d54ce2ea7b4f820
                                        labels.selectAll('.label').data(json.features).enter().append('text')
                                            .attr('transform', function(d) {
                                                return "translate(" + path_bang.centroid(d) + ")";
                                            })
                                            .style('text-anchor', 'middle')
                                            .text(function(d) {
                                                return d.properties.BoroName
                                            });
                                        labels.selectAll('.label').data(json.features).enter().append('text')
                                            .attr('transform', function(d) {
                                                return "translate(" + path_bang.centroid(d) + ")";
                                            })
                                            .style('text-anchor', 'middle')
                                            .text(function(d) {
                                                return d.properties.BoroName
                                            });



                                                    var labels = svg_musik.append('g').attr('class', 'labels');

                                                    //Adding labels as seen on http://bl.ocks.org/pgiraud/9f400d54ce2ea7b4f820
                                                    labels.selectAll('.label').data(json.features).enter().append('text')
                                                        .attr('transform', function(d) {
                                                            return "translate(" + path_musik.centroid(d) + ")";
                                                        })
                                                        .style('text-anchor', 'middle')
                                                        .text(function(d) {
                                                            return d.properties.BoroName
                                                        });
                                                    labels.selectAll('.label').data(json.features).enter().append('text')
                                                        .attr('transform', function(d) {
                                                            return "translate(" + path_musik.centroid(d) + ")";
                                                        })
                                                        .style('text-anchor', 'middle')
                                                        .text(function(d) {
                                                            return d.properties.BoroName
                                                        });



                                                            var labels = svg_talk.append('g').attr('class', 'labels');

                                                            //Adding labels as seen on http://bl.ocks.org/pgiraud/9f400d54ce2ea7b4f820
                                                            labels.selectAll('.label').data(json.features).enter().append('text')
                                                                .attr('transform', function(d) {
                                                                    return "translate(" + path_talk.centroid(d) + ")";
                                                                })
                                                                .style('text-anchor', 'middle')
                                                                .text(function(d) {
                                                                    return d.properties.BoroName
                                                                });
                                                            labels.selectAll('.label').data(json.features).enter().append('text')
                                                                .attr('transform', function(d) {
                                                                    return "translate(" + path_talk.centroid(d) + ")";
                                                                })
                                                                .style('text-anchor', 'middle')
                                                                .text(function(d) {
                                                                    return d.properties.BoroName
                                                                });



//-------------------------------------------------------------------------------------------- //

// -------------------------------- BEGNING -------------------------------------------------- //

                    //Draw the location data points and the kmeans center points
                    drawLocation('KMean2');
                    drawCenters('KMean2');
// -------------------------------------------------------------------------------------------//

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //
//                            FUNCTIONS
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% //

// ------------------------------------------------------------------------------------------ //
//                        CLUSTERING
// ------------------------------------------------------------------------------------------ //

// ------------------------------------- DRAW LOCATION -------------------------------------- //

                    function drawLocation(k_ID) {
                            locations_bang.selectAll("circle").remove()
                            locations_musik.selectAll("circle").remove()
                            locations_talk.selectAll("circle").remove()
                            locations_tv.selectAll("circle").remove()
              //            d3.csv("DataSet2B_final.csv", function(data_loc) {
                            d3.csv("/Data/Clustering_Bang.csv", function(data_loc) {
                                   locations_bang.selectAll("circle")
                                   .data(data_loc)
                                   .enter()
                                   .append("circle")
                                   .attr("cx", function(d) {
                                       return projection([d.X, d.Y])[0];
                                   })
                                   .attr("cy", function(d) {
                                       return projection([d.X, d.Y])[1];
                                   })
                                   .attr("r", 5)
                                   .style("fill", function(d){
                           var value = d[k_ID];
                                         return color[value];
                         })
                         .style("opacity",0.05);
                                });
                           d3.csv("/Data/Clustering_Music.csv", function(data_loc) {
                                 locations_musik.selectAll("circle")
                                 .data(data_loc)
                                 .enter()
                                 .append("circle")
                                 .attr("cx", function(d) {
                                 return projection([d.X, d.Y])[0];
                                   })
                                 .attr("cy", function(d) {
                                       return projection([d.X, d.Y])[1];
                                 })
                                 .attr("r", 5)
                                 .style("fill", function(d){
                             var value = d[k_ID];
                                       return color[value];
                             })
                             .style("opacity",0.05);
                                    });
                                    d3.csv("/Data/Clustering_Talking.csv", function(data_loc) {
                                          locations_talk.selectAll("circle")
                                          .data(data_loc)
                                          .enter()
                                          .append("circle")
                                          .attr("cx", function(d) {
                                          return projection([d.X, d.Y])[0];
                                            })
                                          .attr("cy", function(d) {
                                                return projection([d.X, d.Y])[1];
                                          })
                                          .attr("r", 5)
                                          .style("fill", function(d){
                                      var value = d[k_ID];
                                                return color[value];
                                      })
                                      .style("opacity",0.05);
                                             });
                                             d3.csv("/Data/Clustering_TV.csv", function(data_loc) {
                                                   locations_tv.selectAll("circle")
                                                   .data(data_loc)
                                                   .enter()
                                                   .append("circle")
                                                   .attr("cx", function(d) {
                                                   return projection([d.X, d.Y])[0];
                                                     })
                                                   .attr("cy", function(d) {
                                                         return projection([d.X, d.Y])[1];
                                                   })
                                                   .attr("r", 5)
                                                   .style("fill", function(d){
                                               var value = d[k_ID];
                                                         return color[value];
                                               })
                                               .style("opacity",0.05);
                                                      });
                            }
// ---------------------------------------------------------------------------------------- //

//------------------------------- DRAW CENTERS --------------------------------------------//

                            function drawCenters(k_ID) {
                                centers_bang.selectAll("circle").remove()
                                centers_musik.selectAll("circle").remove()
                                centers_talk.selectAll("circle").remove()
                                centers_tv.selectAll("circle").remove()
                //                d3.csv("DataSet2B_center.csv", function(data_center){
                                  d3.csv("/Data/Center_Bang.csv", function(data_center){
                                    centers_bang.selectAll("circle")
                                        .data(data_center)
                                        .enter()
                                        .append("circle")
                                        .attr("cx", function(d) {
                                            return projection([+d['X_'+k_ID], +d['Y_'+k_ID]])[0]
                                        })
                                        .attr("cy", function(d) {
                                            return projection([+d['X_'+k_ID], +d['Y_'+k_ID]])[1]
                                        })
                                        .attr("r", 10)
                                       .style("fill", 'white')
                                      .attr("stroke", "black")
                                              });
                                    d3.csv("/Data/Center_Music.csv", function(data_center){
                                      centers_musik.selectAll("circle")
                                          .data(data_center)
                                          .enter()
                                          .append("circle")
                                          .attr("cx", function(d) {
                                              return projection([+d['X_'+k_ID], +d['Y_'+k_ID]])[0]
                                          })
                                          .attr("cy", function(d) {
                                              return projection([+d['X_'+k_ID], +d['Y_'+k_ID]])[1]
                                          })
                                          .attr("r", 10)
                                          .style("fill", 'white')
                                         .attr("stroke", "black")
                                                 });
                                      d3.csv("/Data/Center_Talking.csv", function(data_center){
                                        centers_talk.selectAll("circle")
                                            .data(data_center)
                                            .enter()
                                            .append("circle")
                                            .attr("cx", function(d) {
                                                return projection([+d['X_'+k_ID], +d['Y_'+k_ID]])[0]
                                            })
                                            .attr("cy", function(d) {
                                                return projection([+d['X_'+k_ID], +d['Y_'+k_ID]])[1]
                                            })
                                            .attr("r", 10)
                                            .style("fill", 'white')
                                           .attr("stroke", "black")
                                                   });
                                        d3.csv("/Data/Center_TV.csv", function(data_center){
                                          centers_tv.selectAll("circle")
                                              .data(data_center)
                                              .enter()
                                              .append("circle")
                                              .attr("cx", function(d) {
                                                  return projection([+d['X_'+k_ID], +d['Y_'+k_ID]])[0]
                                              })
                                              .attr("cy", function(d) {
                                                  return projection([+d['X_'+k_ID], +d['Y_'+k_ID]])[1]
                                              })
                                              .attr("r", 10)
                                              .style("fill", 'white')
                                             .attr("stroke", "black")
                                                     });
                                }
  //-----------------------------------------------------------------------------------------------------//

  // ------------------------------ CLUSTER BUTTONS ---------------------------------------------------- //

    d3.selectAll(".kernelButton").on("click", function(){
                buttonID = d3.select(this).attr("id")
                drawLocation(buttonID)
                drawCenters(buttonID)
                console.log(buttonID)
                });
// ----------------------------------------------------------------------------------------------------- //
                });
                });
               });
              });



</script>
    </body>
    </html>
